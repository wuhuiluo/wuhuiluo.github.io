<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>高频自测 | 林间有风</title><meta name="description" content="高频考点自测typeof类型判断 typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么   typeof对于原始数据类型来说除了null都可以显示正确的类型  12345typeof 1 &#x2F;&#x2F; &#39;number&#39;typeof &#39;1&#39; &#x2F;&#x2F; &#39;string&#39;typeof undefin"><meta name="keywords" content="Vue,面试,CSDN,ES6,React,前端"><meta name="author" content="林间有风"><meta name="copyright" content="林间有风"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="高频自测"><meta name="twitter:description" content="高频考点自测typeof类型判断 typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么   typeof对于原始数据类型来说除了null都可以显示正确的类型  12345typeof 1 &#x2F;&#x2F; &#39;number&#39;typeof &#39;1&#39; &#x2F;&#x2F; &#39;string&#39;typeof undefin"><meta name="twitter:image" content="https://wuhuiluo.github.io/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="高频自测"><meta property="og:url" content="https://wuhuiluo.github.io/posts/31094/"><meta property="og:site_name" content="林间有风"><meta property="og:description" content="高频考点自测typeof类型判断 typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么   typeof对于原始数据类型来说除了null都可以显示正确的类型  12345typeof 1 &#x2F;&#x2F; &#39;number&#39;typeof &#39;1&#39; &#x2F;&#x2F; &#39;string&#39;typeof undefin"><meta property="og:image" content="https://wuhuiluo.github.io/img/post.jpg"><meta property="article:published_time" content="2021-05-29T07:47:57.832Z"><meta property="article:modified_time" content="2021-05-29T07:48:52.838Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://wuhuiluo.github.io/posts/31094/"><link rel="prev" title="BFC是什么" href="https://wuhuiluo.github.io/posts/12317/"><link rel="next" title="小鹅通面试" href="https://wuhuiluo.github.io/posts/31482/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/gitcalendar/css/gitcalendar.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ae01.alicdn.com/kf/Hce9d0e3650b14688bf616ea3e409c5ebT.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list" aria-hidden="true"></i><span> 媒体</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#高频考点自测"><span class="toc-number">1.</span> <span class="toc-text">高频考点自测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof类型判断"><span class="toc-number">1.1.</span> <span class="toc-text">typeof类型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new的原理"><span class="toc-number">1.2.</span> <span class="toc-text">new的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof的原理"><span class="toc-number">1.3.</span> <span class="toc-text">instanceof的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现以下instanceof"><span class="toc-number">1.3.1.</span> <span class="toc-text">实现以下instanceof</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#说说CSS盒模型-如何进行不同和模型的切换"><span class="toc-number">1.4.</span> <span class="toc-text">说说CSS盒模型,如何进行不同和模型的切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#能不能说一说浏览器本地存储？各自的优缺点"><span class="toc-number">1.5.</span> <span class="toc-text">能不能说一说浏览器本地存储？各自的优缺点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谈谈你对XSS攻击的理解"><span class="toc-number">1.6.</span> <span class="toc-text">谈谈你对XSS攻击的理解</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">林间有风</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list" aria-hidden="true"></i><span> 媒体</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">高频自测</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-05-29 15:47:57"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-05-29</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-05-29 15:48:52"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-05-29</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon far fa-file-word" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5k</span><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-clock" aria-hidden="true"></i><span>阅读时长: 16 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-comments" aria-hidden="true"></i><span>评论数:</span><a href="/posts/31094/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/posts/31094/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="高频考点自测"><a href="#高频考点自测" class="headerlink" title="高频考点自测"></a>高频考点自测</h1><h2 id="typeof类型判断"><a href="#typeof类型判断" class="headerlink" title="typeof类型判断"></a>typeof类型判断</h2><blockquote>
<p>typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么</p>
</blockquote>
<ul>
<li>typeof对于原始数据类型来说除了null都可以显示正确的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 &#x2F;&#x2F; &#39;number&#39;</span><br><span class="line">typeof &#39;1&#39; &#x2F;&#x2F; &#39;string&#39;</span><br><span class="line">typeof undefined &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line">typeof true &#x2F;&#x2F; &#39;boolean&#39;</span><br><span class="line">typeof Symbol() &#x2F;&#x2F; &#39;symbol&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>typeof对于对象来说，除了函数都会显示object，所以typeof不能准确判断变量倒地是什么类型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof &#123;&#125; &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof console.log &#x2F;&#x2F; &#39;function&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们想判断一个对象的正确类型，这时候可以考虑用<code>instanceof</code>因为内部机制是通过原型链来判断的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; function() &#123;&#125;</span><br><span class="line">const p1 &#x3D; new Person()</span><br><span class="line">p1 instanceof Person &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">var str &#x3D; &#39;hello world&#39;</span><br><span class="line">str instanceof String &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">var str1 &#x3D; new String(&#39;hello world&#39;)</span><br><span class="line">str1 instanceof String &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于原始数据类型来说，你想直接通过instanceof来判断数据类型是不行的</p>
</blockquote>
<h2 id="new的原理"><a href="#new的原理" class="headerlink" title="new的原理"></a>new的原理</h2><p><strong>在调用new的过程中会发生四件事</strong></p>
<ul>
<li>新生成一个对象</li>
<li>链接到原型</li>
<li>绑定this</li>
<li>返回新对象</li>
</ul>
<blockquote>
<p>根据以上过程自己实现一个new</p>
</blockquote>
<ul>
<li>创建一个空对象</li>
<li>获取构造函数</li>
<li>设置空对象的原型</li>
<li>绑定this并执行构造函数</li>
<li>确保返回值为对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function create() &#123;</span><br><span class="line">    let obj &#x3D; &#123;&#125;</span><br><span class="line">    let Con &#x3D; [].shift.call(arguments)</span><br><span class="line">    obj.__proto__ &#x3D; Con.prototype</span><br><span class="line">    let result &#x3D; Con.apply(obj,arguments)</span><br><span class="line">    return result instanceof Object ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h2><p><code>instanceof</code>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链是不是能够找到类型的<code>prototype</code></p>
<h3 id="实现以下instanceof"><a href="#实现以下instanceof" class="headerlink" title="实现以下instanceof"></a>实现以下instanceof</h3><ul>
<li>获取类型的原型</li>
<li>获取对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象的原型为null，因为原型链最终为null</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function instanceofLast(left,right) &#123;</span><br><span class="line">    let prototype &#x3D; right.prototype</span><br><span class="line">    let left &#x3D; left.__proto__</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        if(left &#x3D;&#x3D;&#x3D; null || left &#x3D;&#x3D;&#x3D; undefined) return false</span><br><span class="line">        if(prototype &#x3D;&#x3D;&#x3D; left) return true</span><br><span class="line">        left &#x3D; left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说说CSS盒模型-如何进行不同和模型的切换"><a href="#说说CSS盒模型-如何进行不同和模型的切换" class="headerlink" title="说说CSS盒模型,如何进行不同和模型的切换"></a>说说CSS盒模型,如何进行不同和模型的切换</h2><p>W3C标准的盒子模型：width = content（内容）+ padding + border + margin</p>
<p>IE盒子模型: width = content(内容+padding+border) + margin</p>
<p>在common.js公共文件里面设置box-sizing来进行全局设置</p>
<h2 id="能不能说一说浏览器本地存储？各自的优缺点"><a href="#能不能说一说浏览器本地存储？各自的优缺点" class="headerlink" title="能不能说一说浏览器本地存储？各自的优缺点?"></a>能不能说一说浏览器本地存储？各自的优缺点?</h2><p>浏览器的本地存储主要分为<code>Cookie</code>、<code>WebStorage</code>和<code>indexedDB</code>，其中<code>WebStorage</code>又可以分为<code>localStorage</code>和<code>sessionStorage</code>，接下来我们一一分析这些本地存储方案</p>
<p><strong>Cookie</strong></p>
<p><code>Cookie</code>最早开始被设计出来其实并不是做本地存储的，而是为了弥补<code>HTTP</code>在状态管理上的不足</p>
<p><code>HTTP</code>协议是一个无状态协议，客户端向服务端发起请求，服务器返回相应，故事就这样结束了，但是下次发起请求如何让服务端知道客户端是谁呢</p>
<p>这种背景下，就产生了<code>Cookie</code></p>
<p>Cookie的本质就是浏览器里面一个存储的很小的文本文件，内部以键值对的方式来存储(在chorome开发者面板的Application这一栏可以看到)，向同一个域名下发起请求，都会携带相同的Cookie，服务器拿到Cookie进行解析，便能拿到客户端的状态</p>
<p>Cookie的作用很好理解，就是用来做<strong>状态存储</strong>的，但是它也有诸多致命的缺陷</p>
<ul>
<li><ol>
<li>容量缺陷，Cookie的体积上限只有4KB，只能用来存储少量的信息</li>
</ol>
</li>
<li><ol start="2">
<li>性能缺陷，Cookie紧跟域名，不管域名下面的某一个地址需要不需要这个Cookie，请求都会携带上完整的Cookie，这样随着请求的次数增多，其实会造成巨大的性能浪费，因为请求携带了很多不必要的内容</li>
</ol>
</li>
<li><ol start="3">
<li>安全缺陷，由于Cookie以纯文本的形式在浏览器和服务器中传递，很容易被非法用户解惑，然后进行一系列篡改，在Cookie的有效期内重新发给服务器，这是相当危险的，另外在<code>HttpOnly</code>为false的情况下，Cookie信息能直接通过JS脚本来获取</li>
</ol>
</li>
</ul>
<p><strong>localStorage</strong></p>
<p><code>localStorage</code>有一点跟<code>Cookie</code>一样，就是针对一个域名，即在同一个域名下，会存储相同的一段localStorage</p>
<p>不过它相对Cookie还是有相当多的区别的</p>
<ul>
<li><ol>
<li>容量，localStorage的容量上限为5M,相比于Cookie的4K大大增加，当然这个5M是针对一个域名的，因此对于一个域名是持久存储的。</li>
</ol>
</li>
<li><ol start="2">
<li>只存在客户端，默认不参与服务端的通信，这样就很好地避免了Cookie带来的性能问题和安全问题 </li>
</ol>
</li>
<li><ol start="3">
<li>接口封装，通过localStorage暴露在全局，并通过它的<code>setItem</code>和<code>getItem</code>等方法进行操作,非常方便</li>
</ol>
</li>
</ul>
<p>操作方式</p>
<p> 接下来问来具体看看如何操作<code>localStorage</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123; name: &quot;sanyuan&quot;, age: 18 &#125;;</span><br><span class="line">localStorage.setItem(&quot;name&quot;, &quot;sanyuan&quot;); </span><br><span class="line">localStorage.setItem(&quot;info&quot;, JSON.stringify(obj));</span><br></pre></td></tr></table></figure>

<p>接着进入相同的域名就能拿到相应的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name &#x3D; localStorage.getItem(&#39;nane&#39;)</span><br><span class="line">let info &#x3D; JSON.parse(localStorage.getItem(&#39;info&#39;))</span><br></pre></td></tr></table></figure>

<p>从这里可以看出，<code>localStorage</code>其实存储的都是字符串，如果是存储对象需要调用<code>JSON</code>的<code>stringfy</code>方法，并且用<code>JSON.parse</code>来解析成对象</p>
<p><strong>应用场景</strong></p>
<p>利用<code>localStorage</code>的较大容量和持久特性，可以利用<code>localStorage</code>存储一些内容稳定的资源，如官网的<code>logo</code>，存储<code>Base64</code>格式的图片资源，因此利用<code>localStorage</code></p>
<p><strong>sessionStorage</strong></p>
<p>特点</p>
<p><code>sessionStorage</code>以下方面和<code>localStorage</code>一致：</p>
<ul>
<li>容量，容量上线也为5M</li>
<li>只存在客户端，默认不参与服务端通信</li>
<li>接口封装，除了<code>sessionStorage</code>名字有变化，存储方式，操作方式均和<code>localStorage</code>一致</li>
</ul>
<p>但<code>sessionStorage</code> 和 <code>localStorage</code>有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储，会话结束，也就是页面关闭，这部分<code>sessionStorage</code>就不复存在了</p>
<p>应用场景</p>
<ul>
<li><ol>
<li>可以用它做表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢视</li>
</ol>
</li>
<li><ol start="2">
<li>可以利用它存储本地浏览记录，如果页面关闭后不需要这些记录，用<code>sessionStorage</code>就再合适不过了，事实上微博就采取了这样的存储方式</li>
</ol>
</li>
</ul>
<p><strong>indexedDB</strong></p>
<p><code>indexedDB</code>是运行子啊浏览器中的<code>非关系型数据库</code>，本质上是数据库，绝对不是和刚才WebStorage的5M一个量级，理论上这个容量是没有上限的</p>
<p>接着我们来分析一下<code>indexDB</code>的一些重要特性，除了拥有数据库本身的特性，比如<code>支持事务</code>和<code>存储二进制数据</code>，还有一些特性需要格外注意</p>
<ul>
<li><ol>
<li>键值对存储，内部蚕蛹<code>对象仓库</code>存放数据，再这个对象仓库中数据采用<strong>键值对</strong>的方式来存储</li>
</ol>
</li>
<li><ol start="2">
<li>异步操作，数据库的读写属于I/O操作，浏览器中对异步I/O提供了支持</li>
</ol>
</li>
<li><ol start="3">
<li>受同源策略限制，即无法访问跨域的数据库</li>
</ol>
</li>
</ul>
<p> <strong>总结</strong></p>
<p>浏览器中各种本地存储和缓存技术的罚站，给前端带来了大量机会，PWA也正是依托了这些优秀的存储方案才得以罚站起来，重新梳理一下这些本地存储方案</p>
<ul>
<li><ol>
<li><code>cookie</code>并不适合存储，而且存在非常多的缺陷</li>
</ol>
</li>
<li><ol start="2">
<li><code>WebStorage</code>包括 <code>localStorage</code>和<code>sessionStorage</code>，默认不会参与服务器的通信</li>
</ol>
</li>
<li><ol start="3">
<li><code>indexedDB</code>为运行在浏览器上的非关系型数据库，为大量数据的存储提供了接口</li>
</ol>
</li>
</ul>
<h2 id="谈谈你对XSS攻击的理解"><a href="#谈谈你对XSS攻击的理解" class="headerlink" title="谈谈你对XSS攻击的理解"></a>谈谈你对XSS攻击的理解</h2><p>什么是XSS攻击</p>
<p>XSS全称是<code>Cross Site Scripting</code>,为了与<code>CSS</code>区分开来，故简称<code>XSS</code>，翻译过来就是跨站脚本</p>
<p>XSS是指黑客往HTML文件或者DOM中注入恶意脚本,从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段</p>
<p>最开始的时候，这种攻击是通过跨域来实现的，所以叫跨域脚本，现在插入恶意代码的方式越来越多，所以是否跨域注入脚本已经不是唯一的注入手段了，但是这个XSS名字却一直保留至今</p>
<p>注入恶意脚本可以完成这些事情</p>
<ul>
<li><ol>
<li>窃取cookie</li>
</ol>
</li>
<li><ol start="2">
<li>监听用户行为，比如账号密码输入后发给黑客服务器</li>
</ol>
</li>
<li><ol start="3">
<li>在网页中生成浮窗广告</li>
</ol>
</li>
<li><ol start="4">
<li>修改DOM伪造登陆表单</li>
</ol>
</li>
</ul>
<p>一般的情况下,XSS攻击有三种实现方式</p>
<ul>
<li>存储型XSS攻击</li>
<li>反射型XSS攻击</li>
<li>基于DOM的XSS攻击</li>
</ul>
<p><strong>存储型XSS攻击</strong></p>
<p>从图上看，存储型XSS攻击大致步骤如下：</p>
<ol>
<li>首先黑客利用站点漏洞将一段恶意的Javascriptdiamagnetic提交到网站的数据库</li>
<li>然后用户向网站请求包含了恶意Javascript脚本的页面</li>
<li>当用户浏览该页面的时候，恶意脚本就会将用户的Cookie信息等数据上传到服务器</li>
</ol>
<p>比较常见的场景：</p>
<p>在评论区提交一份脚本代码，假设前后端没有做好转义工作，那内容上传到服务器，在页面渲染的时候就会执行，相当于执行一段未知的JS代码，这就是存储型XSS攻击</p>
<p><strong>反射型XSS攻击</strong></p>
<p>反射型XSS攻击指的就是恶意脚本作为网络请求的一部分，随后网站又把恶意的javascript脚本返回给用户，当恶意Javascript脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作</p>
<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;wuhuiluo.com?query&#x3D;&lt;script&gt;alert(&quot;你受到了XSS攻击&quot;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>如上，服务器拿到后解析参数query，最后将内容返回给了浏览器，浏览器将这些内容作为HTML的一部分解析，发现是Javascript脚本，直接执行，这样子被XSS攻击了。</p>
<p>这也就是反射型名字的由来，将恶意脚本作为参数，通过网络请求，最后经过服务器，在反射到HTML文档中，执行解析。</p>
<p>主要注意的就是，「服务器不会存储这些恶意的脚本，这也算是和存储型XSS攻击的区别吧」。</p>
<p>基于DOM的XSS攻击</p>
<p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，，在页面传输的时候劫持输网络包</p>
<p>常见的劫持手段有:</p>
<ul>
<li>WIFI路由劫持</li>
<li>本地恶意软件</li>
</ul>
<p><strong>阻止XSS攻击的策略</strong></p>
<p>以上讲述的XSS攻击原理，都有一个共同点：让恶意脚本直接在浏览器执行</p>
<p>针对XSS攻击，有以下三种解决办法</p>
<p><strong>对输入脚本进行过滤或转码</strong></p>
<p>对用户输入的信息过滤或者是转码</p>
<p>举个例子</p>
<p>转码后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#39;你受到XSS攻击了&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这样的代码在html解析过程中是无法执行的</p>
<p>当然了对<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;a&gt;</code>等关键字标签也是可以过来的，效果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">最后什么都没有剩下</span><br><span class="line"></span><br><span class="line">**利用CSP**</span><br><span class="line"></span><br><span class="line">该安全策略的实现基于一个叫做&#96;Content-Security-Policy&#96;的HTTP首部</span><br><span class="line"></span><br><span class="line">CSP，浏览器中的内容安全策略，核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能</span><br><span class="line"></span><br><span class="line">- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</span><br><span class="line">- 禁止向第三方域提交数据，这样用户数据也不会外泄；</span><br><span class="line">- 提供上报机制，能帮助我们及时发现 XSS 攻击。</span><br><span class="line">- 禁止执行内联脚本和未授权的脚本；</span><br><span class="line"></span><br><span class="line">**利用HttpOnly**</span><br><span class="line"></span><br><span class="line">由于很多XSS攻击都是用来盗用Cookie的，因此还可以通过使用HttpOnly属性来保护我们Cookie的安全，这样子的话，Javascript便无法读取Cookie的值，这样也能很好的防范XSS攻击</span><br><span class="line"></span><br><span class="line">通常服务器可以将某些Cookie设置为HttpOnly标志，HttpOnly是服务器通过HTTP响应头设置的，下面是打开Google时，HTTP响应头的一段</span><br></pre></td></tr></table></figure>
<p>set-cookie: NID=189=M8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**总结**</span><br><span class="line"></span><br><span class="line">&#96;XSS&#96;攻击是指浏览器中执行恶意脚本，然后拿到用户的信息进行操作，主要分为存储型，反射型，文档型，防范的措施包括</span><br><span class="line"></span><br><span class="line">- 对输入内容过滤或者转码，尤其是类似与&#96;&lt;script&gt;&#96;、&#96;&lt;img&gt;&#96;、&#96;&lt;a&gt;&#96;标签</span><br><span class="line">- 利用CSP</span><br><span class="line">- 利用Cookie的HttpOnly属性</span><br><span class="line"></span><br><span class="line">除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作，对于一些不受信任的输入，还可以限制其输入长度，这样可以增大XSS攻击的难度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 能不能说一说CSRF攻击</span><br><span class="line"></span><br><span class="line">什么是CSRF攻击</span><br><span class="line"></span><br><span class="line">CSRF 英文全称是 &#96;Cross-site request forgery&#96;，所以又称为“跨站请求伪造”,是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登陆状态发起的跨站请求，简单来讲，CSRF攻击就是黑客利用了用户的登陆状态，并通过第三方站点来做一些坏事</span><br><span class="line"></span><br><span class="line">一般的情况下，点开一个诱导你的链接，黑客会在你不知情的时候做哪些事情呢</span><br><span class="line"></span><br><span class="line">1. 自动发起Get请求</span><br><span class="line"></span><br><span class="line">黑客网页里面可能有这样一段代码</span><br></pre></td></tr></table></figure>
<img class="lazyload" data-src="http://bank.example/withdraw?amount=10000&for=hacker"  src="/" > 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在受害者访问含有这个img的页面后，浏览器会自动向&#96;http:&#x2F;&#x2F;bank.example&#x2F;withdraw?account&#x3D;xiaoming&amp;amount&#x3D;10000&amp;for&#x3D;hacker&#96;发出一次HTTP请求。</span><br><span class="line"></span><br><span class="line">&#96;bank.example&#96;就会受到包含受害者登陆信息的一次跨域请求</span><br><span class="line"></span><br><span class="line">2. 自动发起Post请求</span><br><span class="line"></span><br><span class="line">黑客网页中有一个表单，自动提交的表单</span><br></pre></td></tr></table></figure>
<form action="http://bank.example/withdraw" method=POST>
<input type="hidden" name="account" value="xiaoming" />
<input type="hidden" name="amount" value="10000" />
<input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</span><br><span class="line"></span><br><span class="line">同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。</span><br><span class="line"></span><br><span class="line">3. 引诱用户点击链接</span><br><span class="line"></span><br><span class="line">这种需要诱导用户去点击链接才会触发，这类的情况比如在论坛中发布照片，照片中嵌入了恶意链接，或者是以广告的形式去诱导，比如：</span><br></pre></td></tr></table></figure>
<a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" target="_blank" rel="noopener" taget="_blank">
重磅消息！！！
<a/>
```

<p>点击后，自动发送 get 请求，接下来和自动发 GET 请求部分同理。</p>
<p>以上三种情况就是CSRF攻击原理，跟XSS对比的话，CSRF攻击并不需要将恶意代码注入HTML中，而是跳转新的页面利用服务器的验证漏洞和用户之前的登陆状态来模拟用户进行操作</p>
<p><strong>防护策略</strong></p>
<p>其实我们可以想到，黑客只能借助受害者的<code>cookie</code>骗取服务器的信任，但是黑客并不能凭借拿到cookie，也看不到cookie的内容，另外，对于服务器返回的结果，由于同源策略的限制，黑客也无法解析</p>
<blockquote>
<p>这就告诉我们，我们需要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要<code>CSRF</code>的保护，而保护的关键，是在请求中放入黑客不能伪造的信息</p>
</blockquote>
<p>用户操作限制–验证码机制</p>
<p>方法：添加验证码来识别是不是用户主要去发起这个请求，由于一定强度的验证码机器无法识别，因此危险网站不能伪造一个完整的请求</p>
<ol>
<li>验证来源站点</li>
</ol>
<p>在服务器验证请求来源的站点，由于大量的CSRF攻击来自第三方站站点，因此服务器可以禁止来自第三方站点的请求，主要通过HTTP请求头中的两个Header</p>
<ul>
<li>Origin Header</li>
<li>Referer Header</li>
</ul>
<p>这两个Header在浏览器发起请求时，大多数情况会带上，并且不能由前端自己定义内容</p>
<p>服务器可以通过接下这两个Header中的域名，确定请求的来源域</p>
<p>其中，Origin只包含域名信息，而Referer包含了具体的URL路径</p>
<p>在某些情况下，这两者都是可以伪造的，通过Ajax中定义请求头即可，安全性略差</p>
<ol start="2">
<li>利用Cookie的SameSite属性</li>
</ol>
<p><code>SameSite</code>可以设置为三个值,<code>Strict</code>、<code>Lax</code>、<code>None</code></p>
<ol>
<li>在<code>Strict</code>模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>sanyuan.com</code>网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。</li>
<li>在<code>Lax</code>模式，就宽松一点了，但是只能在 get 方法提交表单况或者 <code>a</code> 标签发送 <code>get</code> 请求的情况下可以携带 Cookie，其他情况均不能。</li>
<li>在None模式下，Cookie将在所有上下文中发送，即允许跨域发送。</li>
</ol>
<ol start="3">
<li>CSRF Token</li>
</ol>
<p>前面讲到的是CSRF的另一个特征是，攻击者无法直接窃取到用户信息(Cookie,Header,网站内容等)，仅仅是冒用Cookie中的信息</p>
<p>那么我们可以使用Token，在不涉及XSS的前提下，一般黑客很难拿到Token</p>
<p>Token(令牌)做为Web领域验证身份是一个不错的选择</p>
<p>Token的步骤如下</p>
<p>「第一步:将CSRF Token输出到页面中」</p>
<blockquote>
<p>首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了（XSS可能会获取Cookie），否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p>
</blockquote>
<p>「第二步:页面提交的请求携带这个Token」</p>
<blockquote>
<p>对于GET请求，Token将附在请求地址之后，这样URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上：<br><input type=”hidden” name=”csrftoken” value=”tokenvalue”/><br>这样，就把Token以参数的形式加入请求了。</p>
</blockquote>
<p>「第三步：服务器验证Token是否正确」</p>
<blockquote>
<p>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。</p>
</blockquote>
<p><strong>总结</strong></p>
<p>CSRF即跨站请求伪造，本质是冲着浏览器分不清发起请求的是不是真正的用户本人，所以防范的关键在于请求中放入黑客不能伪造的信息，从而防止黑客伪造一个完整的请求欺骗服务器</p>
<p>防范错失：验证码机制，验证来源站点，利用Cookie的SameSite属性，CSRF Token</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">林间有风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wuhuiluo.github.io/posts/31094/">https://wuhuiluo.github.io/posts/31094/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wuhuiluo.github.io" target="_blank">林间有风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://ae01.alicdn.com/kf/Hd5e16194f7bc48349a7aaee73874daddQ.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://ae01.alicdn.com/kf/Ha11ed2fe8af04214a28bd8137a48637bT.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/posts/12317/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BFC是什么</div></div></a></div><div class="next-post pull_right"><a href="/posts/31482/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">小鹅通面试</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/gh/wuhuiluo/jscdn@2.0/js/valine.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  appId: 'b0Ueygg4sFNxOaNq7vzWxRry-gzGzoHsz',
  appKey: 'p1QGVkL3HYKzzy0jG2rRYzuH',
  notify: false,
  verify: false,
  placeholder: '畅所欲言',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: ""
});</script></div></article></main><footer id="footer" style="background-image: url(/img/post.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 林间有风</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>hexo</span></a><span class="footer-separator">|</span><span>林间有风 </span><a href="https://github.com/wuhuiluo" target="_blank" rel="noopener"><span>ButterFly</span></a></div><div class="footer_custom_text">Welcome to 林间有风</div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.0"></head></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/gitcalendar/js/gitcalendar.js"></script><script src="/js/languages.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>